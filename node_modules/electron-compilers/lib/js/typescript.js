'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _compilerBase = require('../compiler-base');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _jsStringEscape = require('js-string-escape');

var _jsStringEscape2 = _interopRequireDefault(_jsStringEscape);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const inputMimeTypes = ['text/typescript', 'text/tsx'];
const d = require('debug')('electron-compile:typescript-compiler');

let ts = null;
let istanbul = null;

const builtinKeys = ['hotModuleReload', 'coverage'];

class TypeScriptCompiler extends _compilerBase.SimpleCompilerBase {
  constructor() {
    super();

    this.outMimeType = 'application/javascript';
    this.compilerOptions = {
      inlineSourceMap: true,
      inlineSources: true
    };
  }

  static getInputMimeTypes() {
    return inputMimeTypes;
  }

  _getParsedConfigOptions(tsCompiler) {
    let parsedConfig = this.parsedConfig;

    if (!parsedConfig) {
      let opts = Object.assign({}, this.compilerOptions);
      let builtinOpts = {};
      builtinKeys.forEach(k => {
        if (k in this.compilerOptions) {
          delete opts[k];
          builtinOpts[k] = this.compilerOptions[k];
        }
      });

      const results = tsCompiler.convertCompilerOptionsFromJson(opts);

      if (results.errors && results.errors.length) {
        throw new Error(JSON.stringify(results.errors));
      }

      parsedConfig = this.parsedConfig = { typescriptOpts: results.options, builtinOpts };
    }

    return parsedConfig;
  }

  compileSync(sourceCode, filePath) {
    ts = ts || require('typescript');
    const options = this._getParsedConfigOptions(ts);

    const isTsx = filePath.match(/\.tsx$/i);
    const transpileOptions = {
      compilerOptions: options.typescriptOpts,
      fileName: filePath.match(/\.(ts|tsx)$/i) ? _path2.default.basename(filePath) : null
    };

    if (isTsx && options.builtinOpts.hotModuleReload !== false) {
      sourceCode = this.addHotModuleLoadingRegistration(sourceCode, filePath, this.getExportsForFile(filePath, options.typescriptOpts));
    }

    let output = ts.transpileModule(sourceCode, transpileOptions);
    let sourceMaps = output.sourceMapText ? output.sourceMapText : null;
    if (options.builtinOpts.coverage) {
      sourceMaps = null;
      istanbul = istanbul || require('istanbul');

      sourceMaps = null;
      output.outputText = new istanbul.Instrumenter().instrumentSync(output.outputText, filePath);
    }

    d(JSON.stringify(output.diagnostics));

    return {
      code: output.outputText,
      mimeType: this.outMimeType,
      sourceMaps
    };
  }

  addHotModuleLoadingRegistration(sourceCode, fileName, exports) {
    if (exports.length < 1) return sourceCode;

    let registrations = exports.map(x => `__REACT_HOT_LOADER__.register(${x}, "${x}", __FILENAME__);\n`);

    let tmpl = `
${sourceCode}

if (typeof __REACT_HOT_LOADER__ !== 'undefined') {
  const __FILENAME__ = "${(0, _jsStringEscape2.default)(fileName)}";
  ${registrations}
}`;

    return tmpl;
  }

  getExportsForFile(fileName, tsOptions) {
    let pg = ts.createProgram([fileName], tsOptions);
    let c = pg.getTypeChecker();
    let ret = [];

    // Walk the tree to search for classes
    let visit = node => {
      if (!this.isNodeExported(node)) return;

      if (node.kind === ts.SyntaxKind.ClassDeclaration || node.kind === ts.SyntaxKind.FunctionDeclaration) {
        ret.push(c.getSymbolAtLocation(node.name).getName());
      }
    };

    let filePathWithForwardSlashes = fileName.replace(/[\\]/g, '/');
    for (const sourceFile of pg.getSourceFiles()) {
      if (sourceFile.fileName !== filePathWithForwardSlashes) {
        continue;
      }

      ts.forEachChild(sourceFile, visit);
    }

    return ret;
  }

  isNodeExported(node) {
    return (node.flags & ts.NodeFlags.Export) !== 0 || node.parent && node.parent.kind === ts.SyntaxKind.SourceFile;
  }

  getCompilerVersion() {
    return require('typescript/package.json').version;
  }
}
exports.default = TypeScriptCompiler;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9qcy90eXBlc2NyaXB0LmpzIl0sIm5hbWVzIjpbImlucHV0TWltZVR5cGVzIiwiZCIsInJlcXVpcmUiLCJ0cyIsImlzdGFuYnVsIiwiYnVpbHRpbktleXMiLCJUeXBlU2NyaXB0Q29tcGlsZXIiLCJjb25zdHJ1Y3RvciIsIm91dE1pbWVUeXBlIiwiY29tcGlsZXJPcHRpb25zIiwiaW5saW5lU291cmNlTWFwIiwiaW5saW5lU291cmNlcyIsImdldElucHV0TWltZVR5cGVzIiwiX2dldFBhcnNlZENvbmZpZ09wdGlvbnMiLCJ0c0NvbXBpbGVyIiwicGFyc2VkQ29uZmlnIiwib3B0cyIsIk9iamVjdCIsImFzc2lnbiIsImJ1aWx0aW5PcHRzIiwiZm9yRWFjaCIsImsiLCJyZXN1bHRzIiwiY29udmVydENvbXBpbGVyT3B0aW9uc0Zyb21Kc29uIiwiZXJyb3JzIiwibGVuZ3RoIiwiRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwidHlwZXNjcmlwdE9wdHMiLCJvcHRpb25zIiwiY29tcGlsZVN5bmMiLCJzb3VyY2VDb2RlIiwiZmlsZVBhdGgiLCJpc1RzeCIsIm1hdGNoIiwidHJhbnNwaWxlT3B0aW9ucyIsImZpbGVOYW1lIiwiYmFzZW5hbWUiLCJob3RNb2R1bGVSZWxvYWQiLCJhZGRIb3RNb2R1bGVMb2FkaW5nUmVnaXN0cmF0aW9uIiwiZ2V0RXhwb3J0c0ZvckZpbGUiLCJvdXRwdXQiLCJ0cmFuc3BpbGVNb2R1bGUiLCJzb3VyY2VNYXBzIiwic291cmNlTWFwVGV4dCIsImNvdmVyYWdlIiwib3V0cHV0VGV4dCIsIkluc3RydW1lbnRlciIsImluc3RydW1lbnRTeW5jIiwiZGlhZ25vc3RpY3MiLCJjb2RlIiwibWltZVR5cGUiLCJleHBvcnRzIiwicmVnaXN0cmF0aW9ucyIsIm1hcCIsIngiLCJ0bXBsIiwidHNPcHRpb25zIiwicGciLCJjcmVhdGVQcm9ncmFtIiwiYyIsImdldFR5cGVDaGVja2VyIiwicmV0IiwidmlzaXQiLCJub2RlIiwiaXNOb2RlRXhwb3J0ZWQiLCJraW5kIiwiU3ludGF4S2luZCIsIkNsYXNzRGVjbGFyYXRpb24iLCJGdW5jdGlvbkRlY2xhcmF0aW9uIiwicHVzaCIsImdldFN5bWJvbEF0TG9jYXRpb24iLCJuYW1lIiwiZ2V0TmFtZSIsImZpbGVQYXRoV2l0aEZvcndhcmRTbGFzaGVzIiwicmVwbGFjZSIsInNvdXJjZUZpbGUiLCJnZXRTb3VyY2VGaWxlcyIsImZvckVhY2hDaGlsZCIsImZsYWdzIiwiTm9kZUZsYWdzIiwiRXhwb3J0IiwicGFyZW50IiwiU291cmNlRmlsZSIsImdldENvbXBpbGVyVmVyc2lvbiIsInZlcnNpb24iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBLE1BQU1BLGlCQUFpQixDQUFDLGlCQUFELEVBQW9CLFVBQXBCLENBQXZCO0FBQ0EsTUFBTUMsSUFBSUMsUUFBUSxPQUFSLEVBQWlCLHNDQUFqQixDQUFWOztBQUVBLElBQUlDLEtBQUssSUFBVDtBQUNBLElBQUlDLFdBQVcsSUFBZjs7QUFFQSxNQUFNQyxjQUFjLENBQUMsaUJBQUQsRUFBb0IsVUFBcEIsQ0FBcEI7O0FBRWUsTUFBTUMsa0JBQU4sMENBQW9EO0FBQ2pFQyxnQkFBYztBQUNaOztBQUVBLFNBQUtDLFdBQUwsR0FBbUIsd0JBQW5CO0FBQ0EsU0FBS0MsZUFBTCxHQUF1QjtBQUNyQkMsdUJBQWlCLElBREk7QUFFckJDLHFCQUFlO0FBRk0sS0FBdkI7QUFJRDs7QUFFRCxTQUFPQyxpQkFBUCxHQUEyQjtBQUN6QixXQUFPWixjQUFQO0FBQ0Q7O0FBRURhLDBCQUF3QkMsVUFBeEIsRUFBb0M7QUFDbEMsUUFBSUMsZUFBZSxLQUFLQSxZQUF4Qjs7QUFFQSxRQUFJLENBQUNBLFlBQUwsRUFBbUI7QUFDakIsVUFBSUMsT0FBT0MsT0FBT0MsTUFBUCxDQUFjLEVBQWQsRUFBa0IsS0FBS1QsZUFBdkIsQ0FBWDtBQUNBLFVBQUlVLGNBQWMsRUFBbEI7QUFDQWQsa0JBQVllLE9BQVosQ0FBcUJDLENBQUQsSUFB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LFFBQUlDLE1BQU0sRUFBVjs7QUFFQTtBQUNBLFFBQUlDLFFBQVNDLElBQUQsSUFBVTtBQUNwQixVQUFJLENBQUMsS0FBS0MsY0FBTCxDQUFvQkQsSUFBcEIsQ0FBTCxFQUFnQzs7QUFFaEMsVUFBSUEsS0FBS0UsSUFBTCxLQUFjaEUsR0FBR2lFLFVBQUgsQ0FBY0MsZ0JBQTVCLElBQWdESixLQUFLRSxJQUFMLEtBQWNoRSxHQUFHaUUsVUFBSCxDQUFjRSxtQkFBaEYsRUFBcUc7QUFDbkdQLFlBQUlRLElBQUosQ0FBU1YsRUFBRVcsbUJBQUYsQ0FBc0JQLEtBQUtRLElBQTNCLEVBQWlDQyxPQUFqQyxFQUFUO0FBQ0Q7QUFDRixLQU5EOztBQVFBLFFBQUlDLDZCQUE2QnRDLFNBQVN1QyxPQUFULENBQWlCLE9BQWpCLEVBQTBCLEdBQTFCLENBQWpDO0FBQ0EsU0FBSyxNQUFNQyxVQUFYLElBQXlCbEIsR0FBR21CLGNBQUgsRUFBekIsRUFBOEM7QUFDNUMsVUFBSUQsV0FBV3hDLFFBQVgsS0FBd0JzQywwQkFBNUIsRUFBd0Q7QUFDdEQ7QUFDRDs7QUFFRHhFLFNBQUc0RSxZQUFILENBQWdCRixVQUFoQixFQUE0QmIsS0FBNUI7QUFDRDs7QUFFRCxXQUFPRCxHQUFQO0FBQ0Q7O0FBRURHLGlCQUFlRCxJQUFmLEVBQXFCO0FBQ25CLFdBQU8sQ0FBQ0EsS0FBS2UsS0FBTCxHQUFhN0UsR0FBRzhFLFNBQUgsQ0FBYUMsTUFBM0IsTUFBdUMsQ0FBdkMsSUFBNkNqQixLQUFLa0IsTUFBTCxJQUFlbEIsS0FBS2tCLE1BQUwsQ0FBWWhCLElBQVosS0FBcUJoRSxHQUFHaUUsVUFBSCxDQUFjZ0IsVUFBdEc7QUFDRDs7QUFFREMsdUJBQXFCO0FBQ25CLFdBQU9uRixRQUFRLHlCQUFSLEVBQW1Db0YsT0FBMUM7QUFDRDtBQTNIZ0U7a0JBQTlDaEYsa0IiLCJmaWxlIjoidHlwZXNjcmlwdC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7U2ltcGxlQ29tcGlsZXJCYXNlfSBmcm9tICcuLi9jb21waWxlci1iYXNlJztcclxuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XHJcbmltcG9ydCBqc0VzY2FwZSBmcm9tICdqcy1zdHJpbmctZXNjYXBlJztcclxuXHJcbmNvbnN0IGlucHV0TWltZVR5cGVzID0gWyd0ZXh0L3R5cGVzY3JpcHQnLCAndGV4dC90c3gnXTtcclxuY29uc3QgZCA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VsZWN0cm9uLWNvbXBpbGU6dHlwZXNjcmlwdC1jb21waWxlcicpO1xyXG5cclxubGV0IHRzID0gbnVsbDtcclxubGV0IGlzdGFuYnVsID0gbnVsbDtcclxuXHJcbmNvbnN0IGJ1aWx0aW5LZXlzID0gWydob3RNb2R1bGVSZWxvYWQnLCAnY292ZXJhZ2UnXTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR5cGVTY3JpcHRDb21waWxlciBleHRlbmRzIFNpbXBsZUNvbXBpbGVyQmFzZSB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIHRoaXMub3V0TWltZVR5cGUgPSAnYXBwbGljYXRpb24vamF2YXNjcmlwdCc7XHJcbiAgICB0aGlzLmNvbXBpbGVyT3B0aW9ucyA9IHtcclxuICAgICAgaW5saW5lU291cmNlTWFwOiB0cnVlLFxyXG4gICAgICBpbmxpbmVTb3VyY2VzOiB0cnVlXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGdldElucHV0TWltZVR5cGVzKCkge1xyXG4gICAgcmV0dXJuIGlucHV0TWltZVR5cGVzO1xyXG4gIH1cclxuXHJcbiAgX2dldFBhcnNlZENvbmZpZ09wdGlvbnModHNDb21waWxlcikge1xyXG4gICAgbGV0IHBhcnNlZENvbmZpZyA9IHRoaXMucGFyc2VkQ29uZmlnO1xyXG5cclxuICAgIGlmICghcGFyc2VkQ29uZmlnKSB7XHJcbiAgICAgIGxldCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb21waWxlck9wdGlvbnMpO1xyXG4gICAgICBsZXQgYnVpbHRpbk9wdHMgPSB7fTtcclxuICAgICAgYnVpbHRpbktleXMuZm9yRWFjaCgoaykgPT4ge1xyXG4gICAgICAgIGlmIChrIGluIHRoaXMuY29tcGlsZXJPcHRpb25zKSB7XHJcbiAgICAgICAgICBkZWxldGUgb3B0c1trXTtcclxuICAgICAgICAgIGJ1aWx0aW5PcHRzW2tdID0gdGhpcy5jb21waWxlck9wdGlvbnNba107XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSB0c0NvbXBpbGVyLmNvbnZlcnRDb21waWxlck9wdGlvbnNGcm9tSnNvbihvcHRzKTtcclxuXHJcbiAgICAgIGlmIChyZXN1bHRzLmVycm9ycyAmJiByZXN1bHRzLmVycm9ycy5sZW5ndGgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkocmVzdWx0cy5lcnJvcnMpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcGFyc2VkQ29uZmlnID0gdGhpcy5wYXJzZWRDb25maWcgPSB7IHR5cGVzY3JpcHRPcHRzOiByZXN1bHRzLm9wdGlvbnMsIGJ1aWx0aW5PcHRzIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBhcnNlZENvbmZpZztcclxuICB9XHJcblxyXG4gIGNvbXBpbGVTeW5jKHNvdXJjZUNvZGUsIGZpbGVQYXRoKSB7XHJcbiAgICB0cyA9IHRzIHx8IHJlcXVpcmUoJ3R5cGVzY3JpcHQnKTtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9nZXRQYXJzZWRDb25maWdPcHRpb25zKHRzKTtcclxuXHJcbiAgICBjb25zdCBpc1RzeCA9IGZpbGVQYXRoLm1hdGNoKC9cXC50c3gkL2kpO1xyXG4gICAgY29uc3QgdHJhbnNwaWxlT3B0aW9ucyA9IHtcclxuICAgICAgY29tcGlsZXJPcHRpb25zOiBvcHRpb25zLnR5cGVzY3JpcHRPcHRzLFxyXG4gICAgICBmaWxlTmFtZTogZmlsZVBhdGgubWF0Y2goL1xcLih0c3x0c3gpJC9pKSA/IHBhdGguYmFzZW5hbWUoZmlsZVBhdGgpIDogbnVsbFxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoaXNUc3ggJiYgb3B0aW9ucy5idWlsdGluT3B0cy5ob3RNb2R1bGVSZWxvYWQgIT09IGZhbHNlKSB7XHJcbiAgICAgIHNvdXJjZUNvZGUgPSB0aGlzLmFkZEhvdE1vZHVsZUxvYWRpbmdSZWdpc3RyYXRpb24oc291cmNlQ29kZSwgZmlsZVBhdGgsIHRoaXMuZ2V0RXhwb3J0c0ZvckZpbGUoZmlsZVBhdGgsIG9wdGlvbnMudHlwZXNjcmlwdE9wdHMpKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgb3V0cHV0ID0gdHMudHJhbnNwaWxlTW9kdWxlKHNvdXJjZUNvZGUsIHRyYW5zcGlsZU9wdGlvbnMpO1xyXG4gICAgbGV0IHNvdXJjZU1hcHMgPSBvdXRwdXQuc291cmNlTWFwVGV4dCA/IG91dHB1dC5zb3VyY2VNYXBUZXh0IDogbnVsbDtcclxuICAgIGlmIChvcHRpb25zLmJ1aWx0aW5PcHRzLmNvdmVyYWdlKSB7XHJcbiAgICAgIHNvdXJjZU1hcHMgPSBudWxsO1xyXG4gICAgICBpc3RhbmJ1bCA9IGlzdGFuYnVsIHx8IHJlcXVpcmUoJ2lzdGFuYnVsJyk7XHJcblxyXG4gICAgICBzb3VyY2VNYXBzID0gbnVsbDtcclxuICAgICAgb3V0cHV0Lm91dHB1dFRleHQgPSAobmV3IGlzdGFuYnVsLkluc3RydW1lbnRlcigpKS5pbnN0cnVtZW50U3luYyhvdXRwdXQub3V0cHV0VGV4dCwgZmlsZVBhdGgpO1xyXG4gICAgfVxyXG5cclxuICAgIGQoSlNPTi5zdHJpbmdpZnkob3V0cHV0LmRpYWdub3N0aWNzKSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY29kZTogb3V0cHV0Lm91dHB1dFRleHQsXHJcbiAgICAgIG1pbWVUeXBlOiB0aGlzLm91dE1pbWVUeXBlLFxyXG4gICAgICBzb3VyY2VNYXBzXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgYWRkSG90TW9kdWxlTG9hZGluZ1JlZ2lzdHJhdGlvbihzb3VyY2VDb2RlLCBmaWxlTmFtZSwgZXhwb3J0cykge1xyXG4gICAgaWYgKGV4cG9ydHMubGVuZ3RoIDwgMSkgcmV0dXJuIHNvdXJjZUNvZGU7XHJcblxyXG4gICAgbGV0IHJlZ2lzdHJhdGlvbnMgPSBleHBvcnRzLm1hcCh4ID0+IFxyXG4gICAgICBgX19SRUFDVF9IT1RfTE9BREVSX18ucmVnaXN0ZXIoJHt4fSwgXCIke3h9XCIsIF9fRklMRU5BTUVfXyk7XFxuYFxyXG4gICAgKTtcclxuXHJcbiAgICBsZXQgdG1wbCA9IGBcclxuJHtzb3VyY2VDb2RlfVxyXG5cclxuaWYgKHR5cGVvZiBfX1JFQUNUX0hPVF9MT0FERVJfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBjb25zdCBfX0ZJTEVOQU1FX18gPSBcIiR7anNFc2NhcGUoZmlsZU5hbWUpfVwiO1xyXG4gICR7cmVnaXN0cmF0aW9uc31cclxufWA7XHJcblxyXG4gICAgcmV0dXJuIHRtcGw7XHJcbiAgfVxyXG5cclxuICBnZXRFeHBvcnRzRm9yRmlsZShmaWxlTmFtZSwgdHNPcHRpb25zKSB7XHJcbiAgICBsZXQgcGcgPSB0cy5jcmVhdGVQcm9ncmFtKFtmaWxlTmFtZV0sIHRzT3B0aW9ucyk7XHJcbiAgICBsZXQgYyA9IHBnLmdldFR5cGVDaGVja2VyKCk7XHJcbiAgICBsZXQgcmV0ID0gW107XHJcblxyXG4gICAgLy8gV2FsayB0aGUgdHJlZSB0byBzZWFyY2ggZm9yIGNsYXNzZXNcclxuICAgIGxldCB2aXNpdCA9IChub2RlKSA9PiB7XHJcbiAgICAgIGlmICghdGhpcy5pc05vZGVFeHBvcnRlZChub2RlKSkgcmV0dXJuO1xyXG4gICAgICBcclxuICAgICAgaWYgKG5vZGUua2luZCA9PT0gdHMuU3ludGF4S2luZC5DbGFzc0RlY2xhcmF0aW9uIHx8IG5vZGUua2luZCA9PT0gdHMuU3ludGF4S2luZC5GdW5jdGlvbkRlY2xhcmF0aW9uKSB7XHJcbiAgICAgICAgcmV0LnB1c2goYy5nZXRTeW1ib2xBdExvY2F0aW9uKG5vZGUubmFtZSkuZ2V0TmFtZSgpKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBsZXQgZmlsZVBhdGhXaXRoRm9yd2FyZFNsYXNoZXMgPSBmaWxlTmFtZS5yZXBsYWNlKC9bXFxcXF0vZywgJy8nKTtcclxuICAgIGZvciAoY29uc3Qgc291cmNlRmlsZSBvZiBwZy5nZXRTb3VyY2VGaWxlcygpKSB7XHJcbiAgICAgIGlmIChzb3VyY2VGaWxlLmZpbGVOYW1lICE9PSBmaWxlUGF0aFdpdGhGb3J3YXJkU2xhc2hlcykge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICB0cy5mb3JFYWNoQ2hpbGQoc291cmNlRmlsZSwgdmlzaXQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXQ7XHJcbiAgfVxyXG5cclxuICBpc05vZGVFeHBvcnRlZChub2RlKSB7XHJcbiAgICByZXR1cm4gKG5vZGUuZmxhZ3MgJiB0cy5Ob2RlRmxhZ3MuRXhwb3J0KSAhPT0gMCB8fCAobm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnQua2luZCA9PT0gdHMuU3ludGF4S2luZC5Tb3VyY2VGaWxlKTtcclxuICB9XHJcblxyXG4gIGdldENvbXBpbGVyVmVyc2lvbigpIHtcclxuICAgIHJldHVybiByZXF1aXJlKCd0eXBlc2NyaXB0L3BhY2thZ2UuanNvbicpLnZlcnNpb247XHJcbiAgfVxyXG59XHJcbiJdfQ==