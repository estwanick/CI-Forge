'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _compilerBase = require('../compiler-base');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _jsStringEscape = require('js-string-escape');

var _jsStringEscape2 = _interopRequireDefault(_jsStringEscape);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const inputMimeTypes = ['text/typescript', 'text/tsx'];
const d = require('debug')('electron-compile:typescript-compiler');

let ts = null;
let istanbul = null;

const builtinKeys = ['hotModuleReload', 'coverage'];

class TypeScriptCompiler extends _compilerBase.SimpleCompilerBase {
  constructor() {
    super();

    this.outMimeType = 'application/javascript';
    this.compilerOptions = {
      inlineSourceMap: true,
      inlineSources: true
    };
  }

  static getInputMimeTypes() {
    return inputMimeTypes;
  }

  _getParsedConfigOptions(tsCompiler) {
    let parsedConfig = this.parsedConfig;

    if (!parsedConfig) {
      let opts = Object.assign({}, this.compilerOptions);
      let builtinOpts = {};
      builtinKeys.forEach(k => {
        if (k in this.compilerOptions) {
          delete opts[k];
          builtinOpts[k] = this.compilerOptions[k];
        }
      });

      const results = tsCompiler.convertCompilerOptionsFromJson(opts);

      if (results.errors && results.errors.length) {
        throw new Error(JSON.stringify(results.errors));
      }

      parsedConfig = this.parsedConfig = { typescriptOpts: results.options, builtinOpts };
    }

    return parsedConfig;
  }

  compileSync(sourceCode, filePath) {
    ts = ts || require('typescript');
    const options = this._getParsedConfigOptions(ts);

    const isTsx = filePath.match(/\.tsx$/i);
    const transpileOptions = {
      compilerOptions: options.typescriptOpts,
      fileName: filePath.match(/\.(ts|tsx)$/i) ? _path2.default.basename(filePath) : null
    };

    if (isTsx && options.builtinOpts.hotModuleReload !== false) {
      sourceCode = this.addHotModuleLoadingRegistration(sourceCode, filePath, this.getExportsForFile(filePath, options.typescriptOpts));
    }

    let output = ts.transpileModule(sourceCode, transpileOptions);
    let sourceMaps = output.sourceMapText ? output.sourceMapText : null;
    if (options.builtinOpts.coverage) {
      sourceMaps = null;
      istanbul = istanbul || require('istanbul');

      sourceMaps = null;
      output.outputText = new istanbul.Instrumenter().instrumentSync(output.outputText, filePath);
    }

    d(JSON.stringify(output.diagnostics));

    return {
      code: output.outputText,
      mimeType: this.outMimeType,
      sourceMaps
    };
  }

  addHotModuleLoadingRegistration(sourceCode, fileName, exports) {
    if (exports.length < 1) return sourceCode;

    let registrations = exports.map(x => {
      let id = `${x}` == 'default' ? "_default" : `${x}`;
      let name = `"${x}"`;
      return `__REACT_HOT_LOADER__.register(${id}, ${name}, __FILENAME__);\n`;
    });

    let tmpl = `
${sourceCode}

if (typeof __REACT_HOT_LOADER__ !== 'undefined') {
  const __FILENAME__ = "${(0, _jsStringEscape2.default)(fileName)}";
  ${registrations}
}`;

    return tmpl;
  }

  getExportsForFile(fileName, tsOptions) {
    let pg = ts.createProgram([fileName], tsOptions);
    let c = pg.getTypeChecker();
    let ret = [];

    // Walk the tree to search for classes
    let visit = node => {
      if (!this.isNodeExported(node)) return;

      if (node.kind === ts.SyntaxKind.ClassDeclaration || node.kind === ts.SyntaxKind.FunctionDeclaration) {
        ret.push(c.getSymbolAtLocation(node.name).getName());
      }
    };

    let filePathWithForwardSlashes = fileName.replace(/[\\]/g, '/');
    for (const sourceFile of pg.getSourceFiles()) {
      if (sourceFile.fileName !== filePathWithForwardSlashes) {
        continue;
      }

      ts.forEachChild(sourceFile, visit);
    }

    return ret;
  }

  isNodeExported(node) {
    return (node.flags & ts.NodeFlags.Export) !== 0 || node.parent && node.parent.kind === ts.SyntaxKind.SourceFile;
  }

  getCompilerVersion() {
    return require('typescript/package.json').version;
  }
}
exports.default = TypeScriptCompiler;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9qcy90eXBlc2NyaXB0LmpzIl0sIm5hbWVzIjpbImlucHV0TWltZVR5cGVzIiwiZCIsInJlcXVpcmUiLCJ0cyIsImlzdGFuYnVsIiwiYnVpbHRpbktleXMiLCJUeXBlU2NyaXB0Q29tcGlsZXIiLCJjb25zdHJ1Y3RvciIsIm91dE1pbWVUeXBlIiwiY29tcGlsZXJPcHRpb25zIiwiaW5saW5lU291cmNlTWFwIiwiaW5saW5lU291cmNlcyIsImdldElucHV0TWltZVR5cGVzIiwiX2dldFBhcnNlZENvbmZpZ09wdGlvbnMiLCJ0c0NvbXBpbGVyIiwicGFyc2VkQ29uZmlnIiwib3B0cyIsIk9iamVjdCIsImFzc2lnbiIsImJ1aWx0aW5PcHRzIiwiZm9yRWFjaCIsImsiLCJyZXN1bHRzIiwiY29udmVydENvbXBpbGVyT3B0aW9uc0Zyb21Kc29uIiwiZXJyb3JzIiwibGVuZ3RoIiwiRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwidHlwZXNjcmlwdE9wdHMiLCJvcHRpb25zIiwiY29tcGlsZVN5bmMiLCJzb3VyY2VDb2RlIiwiZmlsZVBhdGgiLCJpc1RzeCIsIm1hdGNoIiwidHJhbnNwaWxlT3B0aW9ucyIsImZpbGVOYW1lIiwiYmFzZW5hbWUiLCJob3RNb2R1bGVSZWxvYWQiLCJhZGRIb3RNb2R1bGVMb2FkaW5nUmVnaXN0cmF0aW9uIiwiZ2V0RXhwb3J0c0ZvckZpbGUiLCJvdXRwdXQiLCJ0cmFuc3BpbGVNb2R1bGUiLCJzb3VyY2VNYXBzIiwic291cmNlTWFwVGV4dCIsImNvdmVyYWdlIiwib3V0cHV0VGV4dCIsIkluc3RydW1lbnRlciIsImluc3RydW1lbnRTeW5jIiwiZGlhZ25vc3RpY3MiLCJjb2RlIiwibWltZVR5cGUiLCJleHBvcnRzIiwicmVnaXN0cmF0aW9ucyIsIm1hcCIsIngiLCJpZCIsIm5hbWUiLCJ0bXBsIiwidHNPcHRpb25zIiwicGciLCJjcmVhdGVQcm9ncmFtIiwiYyIsImdldFR5cGVDaGVja2VyIiwicmV0IiwidmlzaXQiLCJub2RlIiwiaXNOb2RlRXhwb3J0ZWQiLCJraW5kIiwiU3ludGF4S2luZCIsIkNsYXNzRGVjbGFyYXRpb24iLCJGdW5jdGlvbkRlY2xhcmF0aW9uIiwicHVzaCIsImdldFN5bWJvbEF0TG9jYXRpb24iLCJnZXROYW1lIiwiZmlsZVBhdGhXaXRoRm9yd2FyZFNsYXNoZXMiLCJyZXBsYWNlIiwic291cmNlRmlsZSIsImdldFNvdXJjZUZpbGVzIiwiZm9yRWFjaENoaWxkIiwiZmxhZ3MiLCJOb2RlRmxhZ3MiLCJFeHBvcnQiLCJwYXJlbnQiLCJTb3VyY2VGaWxlIiwiZ2V0Q29tcGlsZXJWZXJzaW9uIiwidmVyc2lvbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsTUFBTUEsaUJBQWlCLENBQUMsaUJBQUQsRUFBb0IsVUFBcEIsQ0FBdkI7QUFDQSxNQUFNQyxJQUFJQyxRQUFRLE9BQVIsRUFBaUIsc0NBQWpCLENBQVY7O0FBRUEsSUFBSUMsS0FBSyxJQUFUO0FBQ0EsSUFBSUMsV0FBVyxJQUFmOztBQUVBLE1BQU1DLGNBQWMsQ0FBQyxpQkFBRCxFQUFvQixVQUFwQixDQUFwQjs7QUFFZSxNQUFNQyxrQkFBTiwwQ0FBb0Q7QUFDakVDLGdCQUFjO0FBQ1o7O0FBRUEsU0FBS0MsV0FBTCxHQUFtQix3QkFBbkI7QUFDQSxTQUFLQyxlQUFMLEdBQXVCO0FBQ3JCQyx1QkFBaUIsSUFESTtBQUVyQkMscUJBQWU7QUFGTSxLQUF2QjtBQUlEOztBQUVELFNBQU9DLGlCQUFQLEdBQTJCO0FBQ3pCLFdBQU9aLGNBQVA7QUFDRDs7QUFFRGEsMEJBQXdCQyxVQUF4QixFQUFvQztBQUNsQyxRQUFJQyxlQUFlLEtBQUtBLFlBQXhCOztBQUVBLFFBQUksQ0FBQ0EsWUFBTCxFQUFtQjtBQUNqQixVQUFJQyxPQUFPQyxPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFrQixLQUFLVCxlQUF2QixDQUFYO0FBQ0EsVUFBSVUsY0FBYyxFQUFsQjtBQUNBZCxrQkFBWWUsT0FBWixDQUFxQkMsQ0FB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QUFSLEVBQW1DcUYsT0FBMUM7QUFDRDtBQTdIZ0U7a0JBQTlDakYsa0IiLCJmaWxlIjoidHlwZXNjcmlwdC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7U2ltcGxlQ29tcGlsZXJCYXNlfSBmcm9tICcuLi9jb21waWxlci1iYXNlJztcclxuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XHJcbmltcG9ydCBqc0VzY2FwZSBmcm9tICdqcy1zdHJpbmctZXNjYXBlJztcclxuXHJcbmNvbnN0IGlucHV0TWltZVR5cGVzID0gWyd0ZXh0L3R5cGVzY3JpcHQnLCAndGV4dC90c3gnXTtcclxuY29uc3QgZCA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VsZWN0cm9uLWNvbXBpbGU6dHlwZXNjcmlwdC1jb21waWxlcicpO1xyXG5cclxubGV0IHRzID0gbnVsbDtcclxubGV0IGlzdGFuYnVsID0gbnVsbDtcclxuXHJcbmNvbnN0IGJ1aWx0aW5LZXlzID0gWydob3RNb2R1bGVSZWxvYWQnLCAnY292ZXJhZ2UnXTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR5cGVTY3JpcHRDb21waWxlciBleHRlbmRzIFNpbXBsZUNvbXBpbGVyQmFzZSB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIHRoaXMub3V0TWltZVR5cGUgPSAnYXBwbGljYXRpb24vamF2YXNjcmlwdCc7XHJcbiAgICB0aGlzLmNvbXBpbGVyT3B0aW9ucyA9IHtcclxuICAgICAgaW5saW5lU291cmNlTWFwOiB0cnVlLFxyXG4gICAgICBpbmxpbmVTb3VyY2VzOiB0cnVlXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGdldElucHV0TWltZVR5cGVzKCkge1xyXG4gICAgcmV0dXJuIGlucHV0TWltZVR5cGVzO1xyXG4gIH1cclxuXHJcbiAgX2dldFBhcnNlZENvbmZpZ09wdGlvbnModHNDb21waWxlcikge1xyXG4gICAgbGV0IHBhcnNlZENvbmZpZyA9IHRoaXMucGFyc2VkQ29uZmlnO1xyXG5cclxuICAgIGlmICghcGFyc2VkQ29uZmlnKSB7XHJcbiAgICAgIGxldCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb21waWxlck9wdGlvbnMpO1xyXG4gICAgICBsZXQgYnVpbHRpbk9wdHMgPSB7fTtcclxuICAgICAgYnVpbHRpbktleXMuZm9yRWFjaCgoaykgPT4ge1xyXG4gICAgICAgIGlmIChrIGluIHRoaXMuY29tcGlsZXJPcHRpb25zKSB7XHJcbiAgICAgICAgICBkZWxldGUgb3B0c1trXTtcclxuICAgICAgICAgIGJ1aWx0aW5PcHRzW2tdID0gdGhpcy5jb21waWxlck9wdGlvbnNba107XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSB0c0NvbXBpbGVyLmNvbnZlcnRDb21waWxlck9wdGlvbnNGcm9tSnNvbihvcHRzKTtcclxuXHJcbiAgICAgIGlmIChyZXN1bHRzLmVycm9ycyAmJiByZXN1bHRzLmVycm9ycy5sZW5ndGgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkocmVzdWx0cy5lcnJvcnMpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcGFyc2VkQ29uZmlnID0gdGhpcy5wYXJzZWRDb25maWcgPSB7IHR5cGVzY3JpcHRPcHRzOiByZXN1bHRzLm9wdGlvbnMsIGJ1aWx0aW5PcHRzIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBhcnNlZENvbmZpZztcclxuICB9XHJcblxyXG4gIGNvbXBpbGVTeW5jKHNvdXJjZUNvZGUsIGZpbGVQYXRoKSB7XHJcbiAgICB0cyA9IHRzIHx8IHJlcXVpcmUoJ3R5cGVzY3JpcHQnKTtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9nZXRQYXJzZWRDb25maWdPcHRpb25zKHRzKTtcclxuXHJcbiAgICBjb25zdCBpc1RzeCA9IGZpbGVQYXRoLm1hdGNoKC9cXC50c3gkL2kpO1xyXG4gICAgY29uc3QgdHJhbnNwaWxlT3B0aW9ucyA9IHtcclxuICAgICAgY29tcGlsZXJPcHRpb25zOiBvcHRpb25zLnR5cGVzY3JpcHRPcHRzLFxyXG4gICAgICBmaWxlTmFtZTogZmlsZVBhdGgubWF0Y2goL1xcLih0c3x0c3gpJC9pKSA/IHBhdGguYmFzZW5hbWUoZmlsZVBhdGgpIDogbnVsbFxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoaXNUc3ggJiYgb3B0aW9ucy5idWlsdGluT3B0cy5ob3RNb2R1bGVSZWxvYWQgIT09IGZhbHNlKSB7XHJcbiAgICAgIHNvdXJjZUNvZGUgPSB0aGlzLmFkZEhvdE1vZHVsZUxvYWRpbmdSZWdpc3RyYXRpb24oc291cmNlQ29kZSwgZmlsZVBhdGgsIHRoaXMuZ2V0RXhwb3J0c0ZvckZpbGUoZmlsZVBhdGgsIG9wdGlvbnMudHlwZXNjcmlwdE9wdHMpKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgb3V0cHV0ID0gdHMudHJhbnNwaWxlTW9kdWxlKHNvdXJjZUNvZGUsIHRyYW5zcGlsZU9wdGlvbnMpO1xyXG4gICAgbGV0IHNvdXJjZU1hcHMgPSBvdXRwdXQuc291cmNlTWFwVGV4dCA/IG91dHB1dC5zb3VyY2VNYXBUZXh0IDogbnVsbDtcclxuICAgIGlmIChvcHRpb25zLmJ1aWx0aW5PcHRzLmNvdmVyYWdlKSB7XHJcbiAgICAgIHNvdXJjZU1hcHMgPSBudWxsO1xyXG4gICAgICBpc3RhbmJ1bCA9IGlzdGFuYnVsIHx8IHJlcXVpcmUoJ2lzdGFuYnVsJyk7XHJcblxyXG4gICAgICBzb3VyY2VNYXBzID0gbnVsbDtcclxuICAgICAgb3V0cHV0Lm91dHB1dFRleHQgPSAobmV3IGlzdGFuYnVsLkluc3RydW1lbnRlcigpKS5pbnN0cnVtZW50U3luYyhvdXRwdXQub3V0cHV0VGV4dCwgZmlsZVBhdGgpO1xyXG4gICAgfVxyXG5cclxuICAgIGQoSlNPTi5zdHJpbmdpZnkob3V0cHV0LmRpYWdub3N0aWNzKSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY29kZTogb3V0cHV0Lm91dHB1dFRleHQsXHJcbiAgICAgIG1pbWVUeXBlOiB0aGlzLm91dE1pbWVUeXBlLFxyXG4gICAgICBzb3VyY2VNYXBzXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgYWRkSG90TW9kdWxlTG9hZGluZ1JlZ2lzdHJhdGlvbihzb3VyY2VDb2RlLCBmaWxlTmFtZSwgZXhwb3J0cykge1xyXG4gICAgaWYgKGV4cG9ydHMubGVuZ3RoIDwgMSkgcmV0dXJuIHNvdXJjZUNvZGU7XHJcblxyXG4gICAgbGV0IHJlZ2lzdHJhdGlvbnMgPSBleHBvcnRzLm1hcCh4ID0+IHtcclxuICAgICAgbGV0IGlkID0gYCR7eH1gID09ICdkZWZhdWx0JyA/IFwiX2RlZmF1bHRcIiA6IGAke3h9YFxyXG4gICAgICBsZXQgbmFtZSA9IGBcIiR7eH1cImBcclxuICAgICAgcmV0dXJuIGBfX1JFQUNUX0hPVF9MT0FERVJfXy5yZWdpc3Rlcigke2lkfSwgJHtuYW1lfSwgX19GSUxFTkFNRV9fKTtcXG5gXHJcbiAgICB9KTtcclxuXHJcbiAgICBsZXQgdG1wbCA9IGBcclxuJHtzb3VyY2VDb2RlfVxyXG5cclxuaWYgKHR5cGVvZiBfX1JFQUNUX0hPVF9MT0FERVJfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBjb25zdCBfX0ZJTEVOQU1FX18gPSBcIiR7anNFc2NhcGUoZmlsZU5hbWUpfVwiO1xyXG4gICR7cmVnaXN0cmF0aW9uc31cclxufWA7XHJcblxyXG4gICAgcmV0dXJuIHRtcGw7XHJcbiAgfVxyXG5cclxuICBnZXRFeHBvcnRzRm9yRmlsZShmaWxlTmFtZSwgdHNPcHRpb25zKSB7XHJcbiAgICBsZXQgcGcgPSB0cy5jcmVhdGVQcm9ncmFtKFtmaWxlTmFtZV0sIHRzT3B0aW9ucyk7XHJcbiAgICBsZXQgYyA9IHBnLmdldFR5cGVDaGVja2VyKCk7XHJcbiAgICBsZXQgcmV0ID0gW107XHJcblxyXG4gICAgLy8gV2FsayB0aGUgdHJlZSB0byBzZWFyY2ggZm9yIGNsYXNzZXNcclxuICAgIGxldCB2aXNpdCA9IChub2RlKSA9PiB7XHJcbiAgICAgIGlmICghdGhpcy5pc05vZGVFeHBvcnRlZChub2RlKSkgcmV0dXJuO1xyXG4gICAgICBcclxuICAgICAgaWYgKG5vZGUua2luZCA9PT0gdHMuU3ludGF4S2luZC5DbGFzc0RlY2xhcmF0aW9uIHx8IG5vZGUua2luZCA9PT0gdHMuU3ludGF4S2luZC5GdW5jdGlvbkRlY2xhcmF0aW9uKSB7XHJcbiAgICAgICAgcmV0LnB1c2goYy5nZXRTeW1ib2xBdExvY2F0aW9uKG5vZGUubmFtZSkuZ2V0TmFtZSgpKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBsZXQgZmlsZVBhdGhXaXRoRm9yd2FyZFNsYXNoZXMgPSBmaWxlTmFtZS5yZXBsYWNlKC9bXFxcXF0vZywgJy8nKTtcclxuICAgIGZvciAoY29uc3Qgc291cmNlRmlsZSBvZiBwZy5nZXRTb3VyY2VGaWxlcygpKSB7XHJcbiAgICAgIGlmIChzb3VyY2VGaWxlLmZpbGVOYW1lICE9PSBmaWxlUGF0aFdpdGhGb3J3YXJkU2xhc2hlcykge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICB0cy5mb3JFYWNoQ2hpbGQoc291cmNlRmlsZSwgdmlzaXQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXQ7XHJcbiAgfVxyXG5cclxuICBpc05vZGVFeHBvcnRlZChub2RlKSB7XHJcbiAgICByZXR1cm4gKG5vZGUuZmxhZ3MgJiB0cy5Ob2RlRmxhZ3MuRXhwb3J0KSAhPT0gMCB8fCAobm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnQua2luZCA9PT0gdHMuU3ludGF4S2luZC5Tb3VyY2VGaWxlKTtcclxuICB9XHJcblxyXG4gIGdldENvbXBpbGVyVmVyc2lvbigpIHtcclxuICAgIHJldHVybiByZXF1aXJlKCd0eXBlc2NyaXB0L3BhY2thZ2UuanNvbicpLnZlcnNpb247XHJcbiAgfVxyXG59XHJcbiJdfQ==